# TP2 Exercise 1: Loop Optimization - Complete Index

## üìã Navigation Guide

### üéØ **Start Here**
1. **QUICK_REFERENCE.md** - TL;DR summary with key results
2. **README.md** - Full overview and getting started guide  
3. **answers.md** - Comprehensive analysis (all exercise questions answered)

---

## üìÅ File Organization

### üìò **Documentation** (1,240 lines total)

| File | Lines | Purpose |
|------|-------|---------|
| **answers.md** | 449 | ‚≠ê Complete exercise analysis with all explanations |
| **README.md** | 343 | Overview, setup, results summary, practical guide |
| **QUICK_REFERENCE.md** | 291 | Quick lookup: results, formulas, best practices |
| **INDEX.md** | 157 | This file - navigation guide |

### üíª **Source Code**

| File | Lines | Description |
|------|-------|-------------|
| **benchmark_all_types.c** | 253 | ‚≠ê Main benchmark supporting all types (U=1,2,4,8,16,32) |
| **BAZOKA_U.c** | 302 | Original comprehensive benchmark for double (U=1-32) |
| **initial_code.c** | 24 | Baseline implementation (no unrolling) |
| **unrol_man.c** | 33 | Example manual unrolling (U=4) |
| **unroll_auto.c** | 113 | Compiler auto-unrolling examples |

### üìä **Data Files**

| File | Size | Content |
|------|------|---------|
| **results_all_types_O0.csv** | 700B | ‚≠ê All types at -O0 (double, float, int, short) |
| **results_all_types_O2.csv** | 700B | ‚≠ê All types at -O2 |
| **results_O0.csv** | 832B | Original double results (all U=1-32) at -O0 |
| **results_O2.csv** | 832B | Original double results (all U=1-32) at -O2 |
| **analysis_output.txt** | ~4KB | Console output from analysis script |
| **performance_summary.csv** | TBD | Exported summary (generated by notebook) |

### üî¨ **Analysis Tools**

| File | Lines | Purpose |
|------|-------|---------|
| **analyze_performance.py** | 225 | ‚≠ê Automated bandwidth analysis with efficiency calculations |
| **comprehensive_analysis.ipynb** | ~500 | ‚≠ê Jupyter notebook with 7 visualization plots |
| **Analysis.ipynb** | ~150 | Original basic plotting notebook |

### üî® **Compiled Binaries**

```
bench_O0, bench_O2                     - Original double benchmarks
bench_all_types_O0, bench_all_types_O2 - Multi-type benchmarks
sum_O0_Unroll4, sum_O2_Unroll4        - Example unrolled versions
```

---

## üéì Exercise Requirements ‚Üí Files Mapping

### ‚úÖ Requirement 1: Implement unrolling U=1,2,4,...,32
- **Code**: `benchmark_all_types.c` (lines 1-253)
- **Alternative**: `BAZOKA_U.c` (all U=1-32 explicitly)

### ‚úÖ Requirement 2: Measure execution time
- **Results**: `results_all_types_O0.csv`, `results_all_types_O2.csv`
- **Analysis**: `analyze_performance.py` (lines 1-225)

### ‚úÖ Requirement 3: Identify best unroll factor
- **Summary**: `QUICK_REFERENCE.md` (section "Optimal Unroll Factors")
- **Details**: `answers.md` (section "Optimal Unrolling Factors")

### ‚úÖ Requirement 4: Compare -O0 vs -O2
- **Analysis**: `analyze_performance.py` (function `compare_optimizations()`)
- **Visualization**: `comprehensive_analysis.ipynb` (cells 3-4)
- **Summary**: `answers.md` (section "Comparison: Manual vs Compiler")

### ‚úÖ Requirement 5: Manual unrolling benefit with -O2
- **Table**: `QUICK_REFERENCE.md` (section "When Does Manual Unrolling Help?")
- **Analysis**: `answers.md` (section "Does Manual Unrolling Help with -O2?")

### ‚úÖ Requirement 6: Repeat for float, int, short
- **Implementation**: `benchmark_all_types.c` (supports all 4 types)
- **Results**: `results_all_types_O0.csv`, `results_all_types_O2.csv`
- **Plots**: `comprehensive_analysis.ipynb` (cell 2)

### ‚úÖ Requirement 7: Estimate bandwidth-limited T_min
- **Formula**: `analyze_performance.py` (function `calculate_bandwidth_limit()`)
- **Visualization**: `comprehensive_analysis.ipynb` (cell 4 - bandwidth analysis)
- **Explanation**: `answers.md` (section "Bandwidth Analysis")

### ‚úÖ Requirement 8: Explain performance saturation
- **Detailed**: `answers.md` (section "Why Performance Improves Then Saturates")
- **Summary**: `QUICK_REFERENCE.md` (section "Performance Improvement Pattern")
- **Script output**: `analyze_performance.py` (function `explain_performance_trends()`)

---

## üöÄ Quick Start Workflows

### **Workflow 1: Just Run the Benchmarks**
```bash
cd TP2/ex1
./bench_all_types_O0 double > results_O0.csv
./bench_all_types_O2 double > results_O2.csv
python3 analyze_performance.py results_O0.csv results_O2.csv
```
‚Üí Get instant analysis with bandwidth calculations

### **Workflow 2: Full Analysis with All Types**
```bash
# Run all benchmarks
for type in double float int short; do
    ./bench_all_types_O0 $type >> results_all_types_O0.csv
    ./bench_all_types_O2 $type >> results_all_types_O2.csv
done

# Analyze
python3 analyze_performance.py results_all_types_O0.csv results_all_types_O2.csv > analysis_output.txt

# View results
cat analysis_output.txt
```

### **Workflow 3: Create Visualizations**
```bash
# Open Jupyter notebook
jupyter notebook comprehensive_analysis.ipynb

# Or use VS Code
code comprehensive_analysis.ipynb
```
‚Üí Generates 7 high-quality plots (300 DPI)

### **Workflow 4: Read Documentation**
```bash
# Quick summary
cat QUICK_REFERENCE.md

# Full guide
cat README.md

# Complete analysis
cat answers.md
```

---

## üìä Key Results Reference

### **Performance Summary**

```
Type    -O0‚Üí-O2   Manual@-O2   Total    BW Efficiency
------------------------------------------------------
double  2.33x     1.60x        3.73x    36.5%
float   3.37x     1.05x        3.37x    17.7%
int     6.02x     2.26x        13.6x    85.3% ‚≠ê
short   12.25x    1.10x        13.5x    44.1%
```

### **Optimal Unroll Factors**

```
Type      -O0    -O2    Why
----------------------------------------
double    U=4    U=8    FP overhead
float     U=4    U=1    Compiler wins
int       U=16   U=16   Fast ops need high U
short     U=16   U=16   Similar to int
```

### **Bandwidth Limits** (30 GB/s assumed)

```
Type      T_min      Measured    Gap
-----------------------------------------
double    0.267 ms   0.732 ms    2.7x
float     0.133 ms   0.752 ms    5.6x
int       0.133 ms   0.156 ms    1.2x ‚≠ê
short     0.067 ms   0.151 ms    2.3x
```

---

## üéØ By Use Case

### **I want to...**

#### **Understand loop unrolling fundamentals**
‚Üí Read: `answers.md` sections 1-3 (Why Performance Improves Then Saturates)

#### **Get quick numbers for my report**
‚Üí Read: `QUICK_REFERENCE.md` (all key tables included)

#### **See pretty graphs**
‚Üí Run: `comprehensive_analysis.ipynb` (7 publication-quality plots)

#### **Implement in my own code**
‚Üí Copy: `benchmark_all_types.c` (lines 14-68 for any type)

#### **Understand bandwidth limits**
‚Üí Read: `answers.md` section "Bandwidth Analysis"  
‚Üí Run: `analyze_performance.py` (calculates efficiency automatically)

#### **Compare my results**
‚Üí Check: `results_all_types_O0.csv` and `results_all_types_O2.csv`

#### **Learn about ILP and loop overhead**
‚Üí Read: `answers.md` section "Why Performance Improves Then Saturates"

#### **Get practical optimization advice**
‚Üí Read: `README.md` section "Practical Recommendations"

---

## üî¨ Deep Dive Topics

### **Loop Overhead**
- **Explanation**: `answers.md` lines 206-230
- **Formula**: `overhead_reduction = U` (unroll by U reduces overhead by factor U)
- **Example**: `QUICK_REFERENCE.md` section "Loop Overhead"

### **Instruction-Level Parallelism (ILP)**
- **Explanation**: `answers.md` lines 232-260
- **Limits**: CPU width 4-8 ops/cycle
- **Assembly**: `QUICK_REFERENCE.md` section "ILP Examples"

### **Memory Bandwidth**
- **Analysis**: `analyze_performance.py` function `calculate_bandwidth_limit()`
- **Formula**: `T_min = (N √ó sizeof(type)) / BW`
- **Visualization**: `comprehensive_analysis.ipynb` cell 4

### **Register Pressure**
- **Explanation**: `answers.md` lines 290-310
- **Limit**: 16 registers on x86-64
- **Impact**: U > 16 causes spills ‚Üí slower

### **Compiler Optimization**
- **Comparison**: `analyze_performance.py` function `compare_optimizations()`
- **Speedups**: 2.33x (double) to 12.25x (short)
- **Auto-vectorization**: Excellent for float/short

---

## üìà Data Flow Diagram

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  benchmark_*.c      ‚îÇ
‚îÇ  (source code)      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ compile (gcc -O0/-O2)
           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  bench_*_O0/O2      ‚îÇ
‚îÇ  (binaries)         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ execute
           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  results_*.csv      ‚îÇ‚îÄ‚îÄ‚Üí analyze_performance.py ‚îÄ‚îÄ‚Üí analysis_output.txt
‚îÇ  (raw timings)      ‚îÇ                             
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                             
           ‚îÇ                                         
           ‚Üì                                         
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ comprehensive_      ‚îÇ‚îÄ‚îÄ‚Üí 7 PNG plots (300 DPI)
‚îÇ analysis.ipynb      ‚îÇ‚îÄ‚îÄ‚Üí performance_summary.csv
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üõ†Ô∏è Compilation Reference

### **Basic Compilation**
```bash
gcc -O0 -g -o bench_O0 benchmark_all_types.c
gcc -O2 -g -o bench_O2 benchmark_all_types.c
```

### **Maximum Performance**
```bash
gcc -O3 -march=native -ffast-math -o bench_fast benchmark_all_types.c
```

### **Debug + Profiling**
```bash
gcc -O2 -g -pg -o bench_profile benchmark_all_types.c
./bench_profile
gprof bench_profile gmon.out > profile.txt
```

### **Assembly Output**
```bash
gcc -O2 -S -o bench.s benchmark_all_types.c
gcc -O2 -fverbose-asm -S -o bench_verbose.s benchmark_all_types.c
```

---

## üìö Learning Path

### **Beginner** (30 minutes)
1. Read `QUICK_REFERENCE.md` (10 min)
2. Look at plots in `comprehensive_analysis.ipynb` (10 min)
3. Skim `README.md` summary tables (10 min)

### **Intermediate** (2 hours)
1. Read `answers.md` sections 1-6 (45 min)
2. Run benchmarks on your machine (30 min)
3. Modify `benchmark_all_types.c` to test U=64 (15 min)
4. Compare your results with provided data (30 min)

### **Advanced** (4+ hours)
1. Complete reading of `answers.md` (1 hr)
2. Implement multiple accumulator version (1 hr)
3. Generate all plots in notebook (30 min)
4. Profile with `perf` or `valgrind` (1 hr)
5. Write optimization recommendations for your HW (30 min)

---

## üéì Quiz Yourself

### **Basic Understanding**
- Q: Why does U=16 outperform U=1?
- A: See `answers.md` section "Loop Overhead Reduction"

- Q: What's the bandwidth limit for double?
- A: 0.267 ms (check `QUICK_REFERENCE.md`)

### **Intermediate**
- Q: Why does int achieve 85% BW efficiency but double only 36%?
- A: See `answers.md` section "Bandwidth Analysis"

- Q: Why is short's compiler speedup (12x) higher than double's (2.3x)?
- A: Excellent auto-vectorization for short integers

### **Advanced**
- Q: Why does U=32 sometimes perform worse than U=16?
- A: Register pressure causes spills (see `answers.md` section "Register Pressure")

- Q: How would multiple accumulators improve performance?
- A: Breaks data dependencies, enables better ILP

---

## üìû Support

### **Missing Results?**
‚Üí Re-run: `./bench_all_types_O0 <type> > results.csv`

### **Want Different Bandwidth?**
‚Üí Edit: `analyze_performance.py` line 15 (`MEMORY_BANDWIDTH_GB_S`)

### **Need More Unroll Factors?**
‚Üí Modify: `benchmark_all_types.c` to add U=64, U=128, etc.

### **Plots Not Generating?**
‚Üí Install: `pip install pandas matplotlib numpy jupyter`

---

## ‚úÖ Completion Checklist

- [x] All source code implemented (4 types, U=1-32)
- [x] All benchmarks executed (-O0 and -O2)
- [x] Analysis script working (bandwidth calculations)
- [x] Documentation complete (1,240 lines)
- [x] Visualizations ready (comprehensive notebook)
- [x] All 8 exercise requirements answered
- [x] Quick reference created
- [x] This index file

**Status**: ‚úÖ **100% COMPLETE**

---

## üìù Summary Statistics

| Metric | Count |
|--------|-------|
| Documentation files | 4 (1,240 lines) |
| Source files | 5 (725 lines) |
| Data files | 6 (CSV + text) |
| Analysis scripts | 2 (Python + Jupyter) |
| Total deliverables | 17 files |
| Exercise requirements met | 8/8 (100%) |

---

**Last Updated**: February 4, 2026  
**Course**: TP2 - Foundations of Parallel Computing  
**Exercise**: 1 - Loop Optimizations  
**Status**: ‚úÖ Complete and Comprehensive
